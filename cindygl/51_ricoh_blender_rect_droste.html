<!DOCTYPE html>
<html>

<head>
<title>Webcam in Cindy JS</title>
<meta charset="UTF-8">
<script type="text/javascript" src="Cindy.js"></script>
<script type="text/javascript" src="CindyGL.js"></script>
<style type="text/css">
  html,body { margin: 0px; padding: 0px; }
  html,body { width: 100%; height: 100%; }
  #overlay{
    position: absolute;
    left:10px;
    top:10px;
    background:rgba(200,200,200,0.5);
    border-radius: 25px;
    padding: 10px; 
  }
  #inp {
    background: rgba(255, 255, 255, 0.3);
    border: none;
  }
  
  #sel {
    background: rgba(255, 255, 255, 0.3);
    border: none;
  }
</style>
<script id="csinit" type="text/x-cindyscript">
video = camera video();

M = [[1,1],[1,-1]];
Z = [[1,0],[0,1]];

//M = [[i,0],[0,1]];
//M = [[-1,0],[0,1]] * [[1,1],[1,-1]];


//f(z) := z;


project2square(z) :=  z/max(|re(z)|,|im(z)|);

project2rectangle(z) := (
  //z/(|re(z/tpts_1)| + |re(z/tpts_2)|);
  z/max(|re(z/(tpts_2-tpts_1))|+|re(z/(tpts_3-tpts_4))|, |re(z/(tpts_3-tpts_2))|+|re(z/(tpts_4-tpts_1))|)
  //p = complex2sphere(z);
  //z/max(|(p*stmid_1)/(stpts_2*stmid_1)|, |(p*stmid_2)/(stpts_2*stmid_2)|)
  //z/max(|(p*stmid_1)/(1+stpts_2*stmid_1)|, |(p*stmid_2)/(1+stpts_2*stmid_2)|)
  //dst = p*stmid_1;
  //sphere2complex(p - stmid_1*(p*stmid_1));
);


f(z) := (z);

//0 -> a, oo -> b, 1 -> c
moebhelp(a, b, c) := (
  alpha = (c-b)/(a-b);
  beta = (c-a)/(b-a);
  [[alpha*a, beta*b],[alpha, beta]]
);

genmoeb(v0, v1, v2, w0, w1, w2) := (
  moebhelp(w0, w1, w2)*inverse(moebhelp(v0, v1, v2))
);

anti(z) := (-1/conjugate(z));

complex2sphere(z) := (
  l2 = |z|*|z|;
  (2*re(z)/(1+l2), 2*im(z)/(1+l2), (-1+l2)/(1+l2))
);

sphere2complex(s) := (
  s = s/|s|;
  (s_1 + i*s_2)/(1-s_3)
);

latlon2complex(latlon) := (
  //phi = latlon_1;
  //alpha = phi/2+pi/4
  tan(latlon_1/2+pi/4)*(cos(latlon_2) + i *sin(latlon_2))
);

moeb(M, z) := (
  regional(w);
  w = M*[z, 1];
  w_1/w_2
);

screen2complex(M, pixel) := (
  //moeb(M, latlon2complex(1.5*[pixel_2, pixel_1]))
  moeb(M, ((pixel_1 + i*pixel_2)))
);

complex2screen(M, z) := (
  gauss(moeb(inverse(M), z)/1.3)
);

complex2latlon(z) := (
  //lambda = arctan2(re(z), im(z));
  //alpha = arctan(|z|);
  //2*alpha + pi/2-phi = pi
  //phi = 2*alpha - pi/2;
  (2*arctan(|z|)-pi/2, arctan2(re(z), im(z)))
);

readcamera(latlon) := (
  imagergba([-pi,-pi/2], [pi,-pi/2], video, (-latlon_2, latlon_1));
);


setcenter() := (
  Z = inverse(M);
  //M = [[1,0],[0,1]];
);


dragging = false;
m0 = [0,1];

ptselect = true;

pts = [];
</script>

<script id="csmousedown" type="text/x-cindyscript">
if(ptselect,
  pts = pts :> complex2sphere(screen2complex(M, mouse()));
  if(length(pts)==4,
    ptselect = false;
  
    center = sphere2complex(sum(pts));
    
    p0 = 0;
    p1 = center;
    
    a1 = sphere2complex(cross(complex2sphere(p0), complex2sphere(p1)));
    a2 = sphere2complex(-cross(complex2sphere(p0), complex2sphere(p1)));

    T = genmoeb(
      p1, a1, a2,
      p0, a1, a2
    );
    
    
    
    mid = apply(1..4, j,
      cross((pts_j), (pts_(mod(j,4)+1)));
    );
    mid = apply(mid, m, m/|m|);

    
    stmid = apply(mid, p, complex2sphere(moeb(T,sphere2complex(p))));
    
    
    tpts = apply(pts, p, moeb((T),sphere2complex(p)));
    stpts = apply(tpts, p, complex2sphere(p));
  
    
    f(z) := (
      z = moeb(T, z);
      offset = re(log(project2rectangle(z)));
      modulus = (2+2*pi*i);
      l = log(z);
      moeb(inverse(T),
        exp(
          mod(
            l - offset,
            modulus
          ) + offset
        )
      );
    );
    
    //f(z) = z;
    
  );
);
M0 = M;
m0 = mouse();
p0 = screen2complex(M, m0);

dragging = true;
</script>

<script id="csmouseup" type="text/x-cindyscript">
dragging = false;
</script>

<script id="csdraw" type="text/x-cindyscript">

if(dragging & |mouse()-m0|>.01,
  p1 = screen2complex(M0, mouse());
  a1 = sphere2complex(cross(complex2sphere(p0), complex2sphere(p1)));
  a2 = sphere2complex(-cross(complex2sphere(p0), complex2sphere(p1)));

  M = genmoeb(
    p1, a1, a2,
    p0, a1, a2
  )*M0;

);


if(ptselect,f(z):=z;);

if (image ready(video),
  //draw image (A, B, video);
  
  colorplot(
    z = screen2complex(M, #);
    //z = moeb(Z, z);
    z = f(z);
    //z = moeb(inverse(Z), z);
    readcamera(complex2latlon(z));
  );
  
  /*
  colorplot(
    imagergba([-1,-720/1280], [1,-720/1280], video, #)
  );*/
);
if(ptselect,

  drawtext((0,0), "select " + (4-length(pts)) + " points for the Droste-rectangle");
  
  forall(pts, p,
    draw(complex2screen(M, sphere2complex(p)));
  );

  ,
  //draw(complex2screen(M, project2rectangle(screen2complex(M, mouse()))));
  /*colorplot(
    z = screen2complex(M, #);
    if(|complex2sphere(z)-mid_1|<|pts_1-mid_1|
    % |complex2sphere(z)-mid_2|<|pts_2-mid_2|
    % |complex2sphere(z)-mid_3|<|pts_3-mid_3|
    % |complex2sphere(z)-mid_4|<|pts_4-mid_4|
    ,
      [1,0,0,.2],
      [0,0,0,0]
    )
  );*/
//  draw(complex2screen(M, center), color->[1,0,0,0]);
  
);



//draw(circle(A,.48));
//errc(A.xy);
</script>
<script type="text/javascript">
var cdy = CindyJS({
  ports: [{id: "CSCanvas", transform:[{visibleRect:[-1,-1,1,1]}]}],
  scripts: "cs*",
  language: "en",
  defaultAppearance: {
  },
  geometry: [
    //{name:"A", type:"Free", pos:[0,0], visible:true},
  ],
  use: ["CindyGL"]
});
</script>
</head>

<body style="font-family:Arial;">
  <div id="CSCanvas" style="width:100vw; height:100vh; border:0px;"></div>
  <div id="overlay">
  <div>
    <p>
  After entering the points, select a pullback function from the list
</p>
  <p><!--
  f(z) = <textarea type="text" id="inp" value="z"  onkeypress="if((event.which ? event.which : event.keyCode)==13) { cdy.evokeCS('f(z) := (' + this.value + ');'); }" size="24">z</textarea>
-->
  <select id="sel" style="width:8em;">
    <option>z</option>
  
    <option value="z = moeb(T, z);
    offset = re(log(project2rectangle(z)));
    modulus = (2+2*pi*i);
    l = log(z);
    moeb(inverse(T),
      exp(
        mod(
          l - offset,
          modulus
        ) + offset
      )
    );
  ">Droste</option>
    <option value="z = moeb(T, z);
    offset = re(log(project2rectangle(z)));
    modulus = (2+2*pi*i);
    l = log(z);
    moeb(inverse(T),
      exp(
        mod(
          l - offset - mod(seconds()/4,2),
          modulus
        ) + offset
      )
    );
  ">Droste +zoom</option>
    <option value="z = moeb(T, z);
    modulus = (2+2*pi*i);
    alpha = modulus/(2*pi*i); l = log(z)*alpha;
    offset = re(log(project2rectangle(exp(l))));
    moeb(inverse(T),
      exp(
        mod(
          l - offset + i*im((2*pi*i)*alpha)*floor(re(l-offset)),
          modulus
        ) + offset
      )
    );
  ">twisted Droste</option>
    <option value="z = moeb(T, z);
    modulus = (2+2*pi*i);
    alpha = modulus/(2*pi*i); l = log(z)*alpha;
    offset = re(log(project2rectangle(exp(l))));
    moeb(inverse(T),
      exp(
        mod(
          l - offset + i*im((2*pi*i)*alpha)*floor(re(l)) - mod(seconds()/4,2),
          modulus
        ) + offset
      )
    );
  ">twisted Droste +zoom</option>
  </select>
</p>
<!--<p><button onclick="cdy.evokeCS('setcenter()')">set current center to 0</button></p>-->
  <script type="text/javascript">
  var select = document.getElementById("sel");
  select.addEventListener('change', function(event) {
  //  document.getElementById('inp').value = this.value;
    cdy.evokeCS('f(z) := (' + this.value + ');');
  }, false);
  </script>
  
  <div>
</body>

</html>
